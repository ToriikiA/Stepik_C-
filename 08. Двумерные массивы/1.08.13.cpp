#include <iostream>
#include <vector>
#include <iomanip>

using namespace std;

// iomanip и setw(4) см. 3 предыдущие задачи.
// Создаю 5 целочисленных переменных: n,m - для хранения размеров массива; cnt = 0 - счетчик для заполнения массива; i = 0, j = -1 - хранят текущий индекс для заполнения массива.
// j = -1, а не 0 - костыль, для универсальности решения.
// Создаю целочисленный двумерный массив A, размерами nxm.
// Затем приступаю к его заполнению особым образом: вместо циклов for буду использовать только while.
// При входе в 1 цикл while происходит проверка верхней границы счетчика: она не может превышать количество элементов массива (кол-во строк m помноженное на кол-во столбцов n). Если это условие перестало выполняться, то значит массив уже заполнен.
// В теле цикла вложены 4 цикла while, каждый отвечающий за заполнение массива в 1 направлении.
// 1 вложенный цикл - заполняет слева направо
// 2 - сверху вниз
// 3 - справа налево
// 4 - снизу вверх
// При входе в каждом из них выполняется проверка границ массива и заполненность элемента, который хотим заполнить (лежит ли уже в нем какое-то значение?).
// Если условие выполняется, то изменяется значение i или j в зависимости от направления движения и к счетчику прибавляется 1 (все это делается с помощью прединкремента. 
// После заполнения, уже стандартным способом полученный массив выводится на экран.

int main() {
    int n, m, cnt = 0, i = 0, j = -1;
    cin >> n >> m;
    vector<vector<int>> A(n, vector<int>(m));
    
    while (cnt < n * m){
        while( j < m - 1 && !A[i][j+1]){
            A[i][++j] = ++cnt;
        }
        while(i < n - 1 && !A[i+1][j]){
            A[++i][j] = ++cnt;
        }
        while(j > 0 && !A[i][j-1]){
            A[i][--j] = ++cnt;
        }
        while (i > 0 && !A[i-1][j]){
            A[--i][j] = ++cnt;
        }
    }
    for(auto x : A){
        for(auto y : x){
            cout << setw(4) << y;
        }
        cout << "\n";
    }
  return 0;
}
