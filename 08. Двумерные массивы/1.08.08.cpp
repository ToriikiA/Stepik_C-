#include <iostream>
#include <vector>

using namespace std;

// Создаю 6 целочисленных переменных: n, m - для хранения размеров вводимого массива; temp - для временного хранения вводимого числа;
// cnt, cnt_max - счетчики для свободных мест, идущих подряд; k - требуемое количество идущих подряд мест
// Заставляю пользователя ввести размеры массива
// Создаю массив A для хранения максимального значения идущих подряд свободных мест в одном ряду (строке) 
// Захожу в цикл for для работы по строкам, обнуляю в нем счетчики cnt, cnt_max.
// В этом цикле вхожу в новый for для работы по столбцам. В нем заставляю пользователя ввести состояние места (свободное - 0, занятое 1)
// Если оно занято, то сбрасываю счетчик cnt в 0, иначе добавляю к нему 1 и проверяю cnt с cnt_max, если cnt больше, то записываю в cnt_max значение cnt.
// После выхода из вложенного цикла for, загоняю найденное максимальное количество идущих подряд мест в этом ряду в массив A.
// После выхода из цикла for заставляю пользователя ввести требуемое количество свободных мест.
// Циклом for прохожусь по массиву A и, если нахожу требуемое кол-во (или даже больше), то вывожу текущий индекс массива + 1 (i+1) (т.к. нормальные люди начинают счет с 1 (пользуются натуральными числами))
//

int main() {
  int n, m, temp, cnt, cnt_max, k;
    cin >> n >> m;
    vector<int> A;
    for(int i = 0; i < n; ++i){
        cnt = 0;
        cnt_max = 0;
        for(int j = 0; j < m; ++j){
            cin >> temp;
            if(temp){
                cnt = 0;
            }
            else{
                ++cnt;
                if(cnt > cnt_max){
                    cnt_max = cnt;
                }
            }
        }
        A.push_back(cnt_max);
    }
    cin >> k;
    for(int i = 0; i < n; ++i){
        if (A[i] >= k){
            cout << i + 1;
            return 0;
        }
    }
    cout << "0";
  return 0;
}
