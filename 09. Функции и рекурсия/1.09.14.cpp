// Не смог решить. Когда-нибудь осилю.
// I'll be back.
//
// Я вернулся

#include <iostream>
#include <vector>

using namespace std;

// https://habr.com/ru/articles/406423/ - полезная статья на Хабре про задачу
// Дано: NxN шахматная доска и N ферзей
//
// Создам булевую  функцию, для проверки использования клетки для установки ферзя. Убеждаюсь, что клетка не попадает под атаку ранее поставленными ферзями.
// На вход подается ссылка на позицию строки в рассматриваемом столбце для ферзя, количество уже установленных ферзей(столбцов) (тоже ссылкой) и ссылка на массив координат уже установленных ферзей.
// В теле функции в цикле for сравнивается номер строки с номерами строк уже установленных ферзей. При установке первого ферзя функция сразу возвращает true, т.к. ferz будет равным 0 и в for программа не войдет;
// Если i-ый ферзь находится на одной диагонали или строке с устанавливаемым, то функция вернет false
//
// prev_rpos, i - координаты поставленного ранее ферзя
// rpos, ferz - координаты устанавливаемого ферзя 
// Чтобы фигуры находились на одной диагонали нужно, чтобы разности координат совпадали по абсолютным значениям.
//
//
// Далее создаю целочисленную функцию place  для вычисления количества комбинаций расстановок.
// На вход подается начальная координата столбца (y) для начала установки, ссылка на  количество клеток в строке/столбце (или количество ферзей, т.к. они все равны) и ссылка на массив координат установленных ферзей
// Если столбец последний, то значит уже установили всех ферзей, кроме последнего и остается единственная клетка для установки
// Поэтому возвращаю 1.
// Иначе, внутри функции создаю целочисленную переменную comb_num = 0, для подсчета установленных ферзей.
// Далее прохожусь в цикле for по всем строкам выбранного столбца.
// Если клетка проходит проверку функцией usable, то в массив с индексом текущего столбца вписываю номер строки. 
// Также, к comb_num прибавляю рекурсивно посчитанные комбинации для следующего стоблца с текущей установкой ферзя.
// После выхода из цикла for возвращаю посчитанные комбинации comb_num;
//
// В теле главной функции main ввожу в целочисленную переменную N число строк/столбцов/ферзей.
// Создаю целочисленный массив pos размером N, который будет хранить в себе координаты ферзей.
// Вывожу резульатат подсчета комбинаций на экран.
//
//
//
// Это была самая трудная задача курса (имхо).

bool usable(int &rpos, int &ferz, vector<int> &pos){
    for (int i = 0; i < ferz; ++i){
        int prev_rpos = pos[i];
        if(prev_rpos == rpos || abs(prev_rpos - rpos) == abs(i - ferz)){
            return false;
        }
    }
    return true;
}

int place(int col, int &N, vector<int> &pos){
    if(row == N){
        return 1;
    }

    int comb_num = 0;

    for(int i = 0; i < N; ++i){
        if(usable(i, col, pos)){
            pos[col] = i;
            comb_num += place(col + 1, N, pos);
        }
    }
    return comb_num;
}

int main() {
  int N;
    cin >> N;
    vector<int> pos(N);
    cout << place(0, N, pos);
  return 0;
}
